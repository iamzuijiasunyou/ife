<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title></title>
    <style type="text/css">
    div {
        display: inline-block;
        border: 1px solid #aaa;
        margin: 10px;
        min-width: 100px;
        min-height: 100px;
    }
    </style>
</head>

<body>
    <div id="root">
        <div>jordan
            <div>kobe</div>
            <div>james</div>
            <div>durant</div>
            <div>curry</div>
            <div>paul</div>
            <div>iriving</div>
            <div>bluke</div>
            <div>harden</div>
        </div>
        <div>
            <div>jacson</div>
            <div>lawen</div>
            <div>waste</div>
            <div>adc</div>
            <div>avc</div>
            <div>abc</div>
            <div>vafdew</div>
            <div>werwer</div>
        </div>
        <div>alone</div>
        <div>
            <div>132</div>
            <div>123</div>
            <div>321</div>
            <div>456</div>
            <div>789</div>
            <div>357</div>
            <div>159</div>
            <div>852</div>
        </div>
    </div>
    <script type="text/javascript">
    /**
     *定义一个节点对象
     */
    function Node(data) {
        this.data = data;
        this.childs = [];
        this.getData = getData;

        function getData() {
            return this.data;
        }
    }
    /**
     *定义一棵树
     */
    function Tree(data) {
        var root = data ? new Node(data) : null;
        this._root = root;
    }

    /*
     *遍历树,将数据返回到arr数组
     */
    Tree.prototype.traverse = function(order,arr) {
        order.call(this, this._root,arr);
    };
    /*
     *把dom转换为自定义的Tree
     *
     */
    Tree.from = function(documentNode) {
        if (!documentNode.children.length) return;

        var tree = new Tree(documentNode);

        traverseDoc2Tree(tree._root, documentNode);

        return tree;

        function traverseDoc2Tree(currentNode, documentNode) {
            var childNodes = documentNode.children;

            if (!childNodes.length) return;
            //循环插入tree
            for (var i = 0, len = childNodes.length; i < len; i++) {
                var node = new Node(childNodes[i]);

                currentNode.childs.push(node);

                traverseDoc2Tree(node, childNodes[i]);
            }
        }
    };


    /**
     *遍历二叉树 返回数组
     */
    function preOrder(currentNode,arr) {
        arr.push(currentNode.data);
        for (var i = 0; i < currentNode.childs.length; i++) {
            preOrder(currentNode.childs[i]);
        };
    }

    //不是二叉树 所以无法执行该方法
    // function inOrder(currentNode) {

    //     if (currentNode !== null || currentNode !== undefined) {
    //         for (var i = 0; i < currentNode.childs.length; i++) {
    //             preOrder(currentNode.childs[i]);
    //         };
    //     }
    // }

    function postOrder(currentNode,arr) {
        for (var i = 0; i < currentNode.childs.length; i++) {
            postOrder(currentNode.childs[i]);
        };
        arr.push(currentNode.data);
    }
    //开始动画
    function start(arr, foundText) {
        foundText = foundText || "";

        var index = 0;
        var loop = setInterval(function() {
            if (index >= arr.length) {
                clearInterval(loop);
                return;
            }
            arr[index].style.backgroundColor = "red";
            index > 0 ? arr[index - 1].style.backgroundColor = "#fff" : null;

            if (arr[index].firstChild.nodeValue.trim() === foundText) {
                clearInterval(loop);
                return;
            };
            index++;
        }, 1000);
    }

    var root = document.getElementById("root");
    var tree = Tree.from(root);

    var arr = [];//遍历结果
    tree.traverse(postOrder,arr);

    start(arr, "abc");
    </script>
</body>

</html>
